/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode RotateRight(ListNode head, int n) {
    
        // temporary nodes to 
        // traverse list
        ListNode RotateNode = head, // new first part of list
                 NewTail = head, // new second part of list
                 TempNodeHolder; // temp place holder
        int i = 0; // number of nodes in list
        
        // initial conditions for 
        // empty list or list with
        // single element
        if(n == 0)
            return head;
        if(head == null )
            return head;
        if(head.next == null)
            return head;
            
        // count nodes in list
        while(RotateNode!=null)
        {
            RotateNode = RotateNode.next;
            i++;
        }
        
        
        if( i == n || n%i == 0)
        {
            // no rotation needed
            return head;
        }
        
        // apply modulos:
        // verify if we don't have 
        // an overlap of n
        else if(i < n)
        {
            // multiple list length
            // rotation needed
            i = n%i;
        }
        else
        {
            // rotation 
            // by ne value needed
            i = n;
        }
		
        // start identifying new head 
        // node
        RotateNode = head;
        
        // advance RotateNode by n nodes
        while(i > 0)
        {
            RotateNode = RotateNode.next;
            i--;
        }
        
        // move NewTail to node prior to
        // new "head" location
        while(RotateNode.next!=null)
        {
            RotateNode = RotateNode.next;
            NewTail = NewTail.next;
        }
        
        // new tail is set at NewTail;
        
        // new head is at RotateNode;
        RotateNode = NewTail.next;
       
        TempNodeHolder = RotateNode;
        
        
        // hold a second copy of 
        // the future head, so
        // we can traverse to last 
        // node of list
        
        while(TempNodeHolder.next!=null)
            TempNodeHolder = TempNodeHolder.next;
        
        // set tail to poin to old 
        // head
        TempNodeHolder.next = head;
        
        // set head to new location
        
        NewTail.next = null;
        return RotateNode;
        
    }
}
